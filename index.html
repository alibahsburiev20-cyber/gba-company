<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
  <title>Roulette ¬∑ 5 –º–∏–Ω</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0f0f17;
      --surface: #171725;
      --primary: #7c3aed;
      --primary-dark: #5b21b6;
      --accent: #a78bfa;
      --text: #e2e8f0;
      --text-muted: #94a3b8;
      --red: #f87171;
    }
    * { margin:0; padding:0; box-sizing:border-box; }
    html, body { height:100%; }
    body {
      font-family: 'Inter', system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100dvh;
      overflow: hidden;
      touch-action: manipulation;
    }
    #setup, #chat-screen {
      position: fixed;
      inset: 0;
      padding: 16px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      transition: opacity .4s ease, transform .4s ease;
    }
    #setup.active, #chat-screen.active { opacity:1; transform:none; }
    #setup.inactive, #chat-screen.inactive { opacity:0; transform:translateY(16px); pointer-events:none; }

    .card {
      background: var(--surface);
      border-radius: 20px;
      padding: 28px 20px;
      width: 100%;
      max-width: 440px;
      margin: 0 auto;
      box-shadow: 0 20px 60px rgba(0,0,0,0.6);
      border: 1px solid rgba(124,58,237,0.1);
    }
    h1 {
      font-size: clamp(1.8rem, 8vw, 2.4rem);
      font-weight: 700;
      background: linear-gradient(90deg, var(--accent), var(--primary));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-align: center;
      margin-bottom: 24px;
    }
    label { font-size: 0.95rem; color: var(--text-muted); margin: 16px 0 6px; display: block; }
    select, input {
      width: 100%;
      padding: 14px 16px;
      border: 1px solid #334155;
      border-radius: 12px;
      background: #1e1e2e;
      color: white;
      font-size: 1rem;
    }
    .mode-toggle {
      display: flex;
      background: #1e1e2e;
      border-radius: 12px;
      padding: 4px;
      margin: 20px 0;
    }
    .mode-btn {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all .2s;
    }
    .mode-btn.active {
      background: var(--primary);
      color: white;
      box-shadow: 0 4px 14px rgba(124,58,237,0.35);
    }
    .mode-btn:not(.active) { color: var(--text-muted); }

    #status {
      font-size: 1.3rem;
      font-weight: 600;
      text-align: center;
      margin: 12px 0 8px;
      min-height: 1.6em;
    }
    #timer {
      font-size: clamp(3.5rem, 18vw, 6rem);
      font-weight: 800;
      letter-spacing: -3px;
      text-align: center;
      color: var(--accent);
      text-shadow: 0 0 40px rgba(167,139,250,0.25);
      margin: 0 0 20px;
    }
    #messages {
      flex: 1;
      overflow-y: auto;
      padding: 16px 12px;
      scrollbar-width: thin;
      -webkit-overflow-scrolling: touch;
    }
    .message {
      margin: 10px 0;
      padding: 12px 16px;
      border-radius: 18px;
      max-width: 82%;
      line-height: 1.45;
      word-break: break-word;
    }
    .mine   { background: var(--primary); color: white; margin-left: auto; border-bottom-right-radius: 6px; }
    .theirs { background: #2d2d44; margin-right: auto; border-bottom-left-radius: 6px; }

    .bottom-bar {
      background: var(--surface);
      padding: 12px 16px;
      border-top: 1px solid #2d2d44;
      display: flex;
      gap: 8px;
      align-items: center;
    }
    #msgInput { flex: 1; }
    button {
      padding: 0 20px;
      border: none;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all .18s;
      min-width: 60px;
    }
    .btn-main   { background: var(--primary); color: white; }
    .btn-main:hover   { background: var(--primary-dark); }
    .btn-danger { background: var(--red); color: white; }
    button:disabled { opacity: 0.4; }

    audio { width: 180px; margin: 4px 0; }

    #recordingOverlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.75);
      z-index: 1000;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      color: white;
      font-size: 2rem;
      text-align: center;
    }
    #recTimer { font-size: 4rem; margin: 20px 0; }

    @media (max-width: 480px) {
      .card { padding: 24px 16px; border-radius: 16px; }
      .bottom-bar { padding: 10px 12px; gap: 6px; }
      button { padding: 0 14px; font-size: 0.95rem; }
    }
  </style>
</head>
<body>

<div id="setup" class="active">
  <div class="card">
    <h1>Roulette</h1>

    <label>–Ø</label>
    <select id="myGender">
      <option value="m">–ü–∞—Ä–µ–Ω—å</option>
      <option value="f">–î–µ–≤—É—à–∫–∞</option>
      <option value="o">–î—Ä—É–≥–æ–µ</option>
    </select>

    <label>–•–æ—á—É —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞</label>
    <select id="wantGender">
      <option value="any">–õ—é–±–æ–π</option>
      <option value="m">–ü–∞—Ä–µ–Ω—å</option>
      <option value="f">–î–µ–≤—É—à–∫–∞</option>
      <option value="o">–î—Ä—É–≥–æ–µ</option>
    </select>

    <div class="mode-toggle">
      <button class="mode-btn active" data-mode="chat">–û–±—ã—á–Ω—ã–π</button>
      <button class="mode-btn" data-mode="rp">–†–æ–ª–µ–≤–∞—è</button>
    </div>

    <button id="startBtn" class="btn-main" style="width:100%;padding:16px;font-size:1.1rem;margin-top:20px;">
      –ù–∞—á–∞—Ç—å –ø–æ–∏—Å–∫
    </button>
  </div>
</div>

<div id="chat-screen" class="inactive" style="flex-direction:column;">
  <div id="status">–ü–æ–∏—Å–∫...</div>
  <div id="timer">05:00</div>
  <div id="messages"></div>

  <div class="bottom-bar">
    <input id="msgInput" placeholder="–°–æ–æ–±—â–µ–Ω–∏–µ‚Ä¶" disabled autocomplete="off"/>
    <button id="sendBtn" class="btn-main" disabled>‚Üí</button>
    <button id="recordBtn" class="btn-main" disabled>üé§</button>
  </div>

  <div class="bottom-bar" style="justify-content:center;gap:12px;padding:10px 16px;">
    <button id="nextBtn" class="btn-main" disabled>–°–ª–µ–¥—É—é—â–∏–π</button>
    <button id="stopBtn" class="btn-main" disabled>–ó–∞–≤–µ—Ä—à–∏—Ç—å</button>
    <button id="reportBtn" class="btn-danger" style="display:none;">–ñ–∞–ª–æ–±–∞</button>
  </div>
</div>

<div id="recordingOverlay">
  <div>–ó–∞–ø–∏—Å—å...</div>
  <div id="recTimer">00:00</div>
  <div>–û—Ç–ø—É—Å—Ç–∏—Ç–µ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏</div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js";
  import { getDatabase, ref, push, onValue, remove, set, serverTimestamp, get } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-database.js";
  import { getStorage, ref as sRef, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-storage.js";

  const config = {
    apiKey: "AIzaSyDWvsB0nsBWxQZLZ9ppIaeH4hZK_6DBeDw",
    authDomain: "chatroullet-80ba8.firebaseapp.com",
    databaseURL: "https://chatroullet-80ba8-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "chatroullet-80ba8",
    storageBucket: "chatroullet-80ba8.firebasestorage.app",
    messagingSenderId: "494898766457",
    appId: "1:494898766457:web:356fddf6d48b8730052aa8",
    measurementId: "G-SPB60G3NNQ"
  };

  const app = initializeApp(config);
  const db = getDatabase(app);
  const storage = getStorage(app);

  const myId = localStorage.crId || (localStorage.crId = 'u-' + Math.random().toString(36).slice(2, 11));

  let room = null;
  let timerInterval = null;
  let partner = null;
  let mode = 'chat';
  let mediaRecorder = null;
  let audioChunks = [];
  let currentStream = null;
  let recTimerInterval = null;
  let isRecording = false;
  let recordingStartTime = 0;

  const VOICE_MIN_DURATION = 1000; // 1 —Å–µ–∫ –º–∏–Ω–∏–º—É–º
  const VOICE_MAX_DURATION = 5000; // 5 —Å–µ–∫ –º–∞–∫—Å–∏–º—É–º

  const $ = s => document.getElementById(s);
  const els = {
    setup: $('setup'),
    chatScreen: $('chat-screen'),
    status: $('status'),
    timer: $('timer'),
    messages: $('messages'),
    input: $('msgInput'),
    send: $('sendBtn'),
    start: $('startBtn'),
    next: $('nextBtn'),
    stop: $('stopBtn'),
    report: $('reportBtn'),
    record: $('recordBtn'),
    overlay: $('recordingOverlay'),
    recTimer: $('recTimer')
  };

  // Mode toggle
  document.querySelectorAll('[data-mode]').forEach(el => {
    el.onclick = () => {
      document.querySelectorAll('[data-mode]').forEach(e => e.classList.remove('active'));
      el.classList.add('active');
      mode = el.dataset.mode;
    };
  });

  const formatTimer = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const setTimer = (seconds) => {
    els.timer.textContent = formatTimer(seconds);
  };

  const endChat = (reason) => {
    clearInterval(timerInterval);
    els.status.textContent = reason || '–ß–∞—Ç –∑–∞–≤–µ—Ä—à—ë–Ω';
    els.input.disabled = true;
    els.send.disabled = true;
    els.next.disabled = true;
    els.record.disabled = true;
    els.report.style.display = 'inline-block';
    els.stop.disabled = false;
  };

  const cleanup = async () => {
    clearInterval(timerInterval);
    clearInterval(recTimerInterval);
    if (currentStream) {
      currentStream.getTracks().forEach(track => track.stop());
      currentStream = null;
    }
    if (mediaRecorder && mediaRecorder.state === 'recording') {
      mediaRecorder.stop();
    }
    if (room) {
      await remove(ref(db, `rooms/${room}`));
    }
    room = partner = null;
    els.messages.innerHTML = '';
    isRecording = false;
  };

  // Voice recording: press ‚Üí record ‚Üí release ‚Üí send
  els.record.onmousedown = els.record.ontouchstart = async (e) => {
    e.preventDefault();
    if (els.record.disabled || isRecording) return;

    try {
      isRecording = true;
      recordingStartTime = Date.now();
      currentStream = await navigator.mediaDevices.getUserMedia({ 
        audio: { 
          echoCancellation: true, 
          noiseSuppression: true,
          autoGainControl: true
        } 
      });

      mediaRecorder = new MediaRecorder(currentStream, { mimeType: 'audio/webm' });
      audioChunks = [];

      mediaRecorder.ondataavailable = (e) => {
        audioChunks.push(e.data);
      };

      mediaRecorder.onstop = async () => {
        clearInterval(recTimerInterval);
        els.overlay.style.display = 'none';
        els.record.textContent = 'üé§';
        els.record.style.background = '';

        const blob = new Blob(audioChunks, { type: 'audio/webm' });
        audioChunks = [];
        
        const recordingDuration = Date.now() - recordingStartTime;

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ (1 —Å–µ–∫)
        if (recordingDuration < VOICE_MIN_DURATION) {
          console.log('–ó–∞–ø–∏—Å—å —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∞—è:', recordingDuration, '–º—Å');
          currentStream?.getTracks().forEach(t => t.stop());
          currentStream = null;
          isRecording = false;
          els.status.textContent = '–ó–∞–ø–∏—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –Ω–µ –º–µ–Ω–µ–µ 1 —Å–µ–∫';
          setTimeout(() => {
            els.status.textContent = '–ì–æ—Ç–æ–≤–æ –∫ —á–∞—Ç—É';
          }, 2000);
          return;
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ (5 —Å–µ–∫)
        if (recordingDuration > VOICE_MAX_DURATION) {
          console.log('–ó–∞–ø–∏—Å—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –Ω–∞ 5 —Å–µ–∫');
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–º–µ—Ä–∞ –±–ª–æ–±–∞ (–¥–æ–ª–∂–µ–Ω –±—ã—Ç—å > 0)
        if (blob.size === 0) {
          console.log('–ü—É—Å—Ç–æ–π –±–ª–æ–± –∞—É–¥–∏–æ');
          currentStream?.getTracks().forEach(t => t.stop());
          currentStream = null;
          isRecording = false;
          els.status.textContent = '–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏';
          return;
        }

        try {
          // –ó–∞–≥—Ä—É–∑–∫–∞ –≤ Storage
          const timestamp = Date.now();
          const path = `voice/${room}/${myId}/${timestamp}.webm`;
          const storageRef = sRef(storage, path);

          console.log('–ó–∞–≥—Ä—É–∑–∫–∞ –≥–æ–ª–æ—Å–∞:', path, '–†–∞–∑–º–µ—Ä:', blob.size, '–±–∞–π—Ç');
          await uploadBytes(storageRef, blob);
          const url = await getDownloadURL(storageRef);

          console.log('–ì–æ–ª–æ—Å —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω:', url);

          // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å—Å—ã–ª–∫–∏ –≤ –ë–î –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏
          await push(ref(db, `rooms/${room}/msgs`), {
            by: myId,
            type: 'voice',
            url: url,
            duration: Math.round(recordingDuration / 1000), // –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
            ts: serverTimestamp()
          });

          els.status.textContent = '–ì–æ–ª–æ—Å –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω ‚úì';
          setTimeout(() => {
            els.status.textContent = '–ì–æ—Ç–æ–≤–æ –∫ —á–∞—Ç—É';
          }, 1500);

        } catch (uploadError) {
          console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏:', uploadError);
          els.status.textContent = '–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≥–æ–ª–æ—Å–∞';
          setTimeout(() => {
            els.status.textContent = '–ì–æ—Ç–æ–≤–æ –∫ —á–∞—Ç—É';
          }, 2000);
        } finally {
          currentStream?.getTracks().forEach(t => t.stop());
          currentStream = null;
          isRecording = false;
        }
      };

      mediaRecorder.onerror = (e) => {
        console.error('–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏:', e.error);
        isRecording = false;
        els.status.textContent = '–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏';
      };

      mediaRecorder.start();
      els.record.textContent = '‚ñ†';
      els.record.style.background = '#ef4444';

      // Show recording overlay
      els.overlay.style.display = 'flex';
      let recSeconds = 0;
      els.recTimer.textContent = '00:00';

      recTimerInterval = setInterval(() => {
        recSeconds++;
        els.recTimer.textContent = formatTimer(recSeconds);
        
        // Auto stop after 5 seconds
        if (recSeconds >= 5) {
          if (mediaRecorder && mediaRecorder.state === 'recording') {
            mediaRecorder.stop();
          }
        }
      }, 1000);

    } catch (err) {
      console.error('–û—à–∏–±–∫–∞ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞:', err);
      els.status.textContent = '–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É';
      isRecording = false;
    }
  };

  els.record.onmouseup = els.record.ontouchend = () => {
    if (mediaRecorder && mediaRecorder.state === 'recording') {
      mediaRecorder.stop();
    }
  };

  // Start chat
  els.start.onclick = async () => {
    if (await isBlocked()) {
      els.status.textContent = '–í—ã –≤—Ä–µ–º–µ–Ω–Ω–æ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã';
      return;
    }

    const myGender = $('myGender').value;
    const wantGender = $('wantGender').value;

    els.setup.classList.remove('active');
    els.setup.classList.add('inactive');
    els.chatScreen.classList.remove('inactive');
    els.chatScreen.classList.add('active');

    els.status.textContent = '–ü–æ–∏—Å–∫ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞‚Ä¶';
    els.start.disabled = true;

    // Add self to queue
    await set(ref(db, `queue/${myId}`), {
      g: myGender,
      w: wantGender,
      m: mode,
      ts: serverTimestamp()
    });

    const unsubscribe = onValue(ref(db, 'queue'), async (snap) => {
      if (room || !snap.exists()) return;

      const waiting = snap.val() || {};
      const possible = Object.entries(waiting).filter(([id, userData]) =>
        id !== myId &&
        !userData.blocked &&
        (userData.w === 'any' || userData.w === myGender) &&
        (wantGender === 'any' || wantGender === userData.g) &&
        userData.m === mode
      );

      if (!possible.length) return;

      // Found a match
      const [partnerId] = possible[0];
      partner = partnerId;
      room = [myId, partnerId].sort().join('¬∑');

      unsubscribe();

      // Remove from queue and create room
      await Promise.all([
        remove(ref(db, `queue/${myId}`)),
        remove(ref(db, `queue/${partnerId}`)),
        set(ref(db, `rooms/${room}`), { ts: serverTimestamp(), mode })
      ]);

      els.status.textContent = '–°–æ–±–µ—Å–µ–¥–Ω–∏–∫ –Ω–∞–π–¥–µ–Ω!';
      els.input.disabled = false;
      els.send.disabled = false;
      els.record.disabled = false;
      els.next.disabled = false;
      els.stop.disabled = false;

      // Start 5-minute timer
      let secondsLeft = 300;
      setTimer(secondsLeft);

      timerInterval = setInterval(() => {
        secondsLeft--;
        if (secondsLeft >= 0) {
          setTimer(secondsLeft);
        }
        if (secondsLeft <= 0) {
          clearInterval(timerInterval);
          els.next.click();
        }
      }, 1000);

      // Listen for messages
      const messagesUnsubscribe = onValue(ref(db, `rooms/${room}/msgs`), (snap) => {
        els.messages.innerHTML = '';
        if (snap.exists()) {
          snap.forEach((child) => {
            const msg = child.val();
            const msgDiv = document.createElement('div');
            msgDiv.className = `message ${msg.by === myId ? 'mine' : 'theirs'}`;

            if (msg.type === 'voice') {
              const audioContainer = document.createElement('div');
              const audio = document.createElement('audio');
              audio.controls = true;
              audio.src = msg.url;
              
              const durationText = document.createElement('span');
              durationText.style.fontSize = '0.85rem';
              durationText.style.opacity = '0.8';
              durationText.style.marginLeft = '8px';
              durationText.textContent = msg.duration ? `${msg.duration}—Å` : '';
              
              audioContainer.appendChild(audio);
              if (msg.duration) audioContainer.appendChild(durationText);
              msgDiv.appendChild(audioContainer);
            } else {
              msgDiv.textContent = msg.t || '';
            }

            els.messages.appendChild(msgDiv);
            els.messages.scrollTop = els.messages.scrollHeight;
          });
        }
      });

      // Check if partner left
      const roomUnsubscribe = onValue(ref(db, `rooms/${room}`), (snap) => {
        if (!snap.exists() && room) {
          endChat('–°–æ–±–µ—Å–µ–¥–Ω–∏–∫ –≤—ã—à–µ–ª');
          messagesUnsubscribe();
          roomUnsubscribe();
        }
      });
    });
  };

  // Send text message
  els.send.onclick = () => {
    const text = els.input.value.trim();
    if (!text || !room) return;

    push(ref(db, `rooms/${room}/msgs`), {
      by: myId,
      t: text,
      ts: serverTimestamp()
    });

    els.input.value = '';
  };

  els.input.onkeypress = (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      els.send.click();
    }
  };

  // Next chat
  els.next.onclick = async () => {
    await cleanup();
    els.status.textContent = '–ü–æ–∏—Å–∫ –Ω–æ–≤–æ–≥–æ‚Ä¶';
    setTimer(300);
    els.input.disabled = true;
    els.send.disabled = true;
    els.record.disabled = true;
    els.next.disabled = true;
    els.report.style.display = 'none';
    els.start.disabled = false;
    els.start.click();
  };

  // Stop chat
  els.stop.onclick = async () => {
    await cleanup();
    els.setup.classList.remove('inactive');
    els.setup.classList.add('active');
    els.chatScreen.classList.remove('active');
    els.chatScreen.classList.add('inactive');
    els.status.textContent = '–°–µ—Å—Å–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞';
    els.start.disabled = false;
  };

  // Report user
  els.report.onclick = async () => {
    if (!partner) return;
    const blockUntil = Date.now() + 10800000; // 3 hours
    await set(ref(db, `blocks/${partner}`), blockUntil);
    els.status.textContent = '–ñ–∞–ª–æ–±–∞ –ø—Ä–∏–Ω—è—Ç–∞ ¬∑ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –Ω–∞ 3 —á–∞—Å–∞';
    els.report.disabled = true;
  };

  // Check if blocked
  async function isBlocked() {
    try {
      const snap = await get(ref(db, `blocks/${myId}`));
      if (!snap.exists()) return false;

      const blockTime = snap.val();
      if (blockTime > Date.now()) {
        return true;
      }

      // Block expired
      await remove(ref(db, `blocks/${myId}`));
      return false;
    } catch (err) {
      console.error('–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –±–ª–æ–∫–∞:', err);
      return false;
    }
  }

  // Cleanup on page unload
  window.onbeforeunload = () => {
    if (currentStream) {
      currentStream.getTracks().forEach(t => t.stop());
    }
    if (room) {
      remove(ref(db, `rooms/${room}`));
    }
    remove(ref(db, `queue/${myId}`));
  };
</script>
</body>
</html>
